#!/bin/bash

declare -A CONFIG
export CONFIG
ETC=/etc
export ETCDIR=$ETC/snapsched
export CFGFILE=$ETCDIR/config
export CRONTAB=$ETC/cron.d/snapsched
export TMPBASE=/tmp/ssched
export UMNT

export OSILENT=

if [ "${BASH_VERSINFO[0]}" -lt 4 ] ; then
	# we're screwed
	OLDBASH=true
elif [ "${BASH_VERSINFO[1]}" -lt 3 ] ; then
	# we're still screwed (PIPESTATUS)
	OLDBASH=true
else
	OLDBASH=false
fi
export OLDBASH

# utility to write optional text to stdout or what. ev.
# uses global OSILENT variable
omsg ()
{
	if [ -z "$OSILENT" ] ; then
		if [ "$#" -ge 1 ] ; then
			echo "$@"
		else
			cat
		fi
	elif [ "$#" -lt 1 ] ; then
		cat >/dev/null
	fi
}

# utility for echo/cat to stderr
serr()
{
	if [ "$#" -ge 1 ] ; then
		echo "$@" >/dev/stderr
	else
		cat >/dev/stderr
	fi
}


# create a temp file of name $1 in $TMPBASE
_ssched_mktemp()
{
	local TMPFILE=`basename $1`
	if [ ! -d $TMPBASE ] ; then
		mkdir -p $TMPBASE
	fi
	touch $TMPBASE/$TMPFILE
}


# remove a temp file of name $1 in $TMPBASE, and rmdir $TMPBASE if empty
_ssched_rmtemp()
{
	local TMPFILE=`basename $1`
	rm -f $TMPBASE/$TMPFILE >/dev/null 2>&1
	if [ -d $TMPBASE ] ; then
		# this next part is super racy.  i hope there isn't a hundred
		# ssched jobs running on the same machine one day
		rmdir $TMPBASE >/dev/null 2>&1
	fi
}


# translate interval to single uppercase letter
# arg: {hourly,daily,weekly,monthly}
_ssched_int2l()
{
	case $1 in
		hourly)
			echo H
		;;
		daily)
			echo D
		;;
		weekly)
			echo W
		;;
		monthly)
			echo M
		;;
	esac
}


# translate interval to snapsched sub dir for that interval
# arg: {hourly,daily,weekly,monthly}
_ssched_int2dir()
{
	local -u I

	case $1 in
		hourly|daily|weekly|monthly)
			I=$1
		;;
		h|H|hour|hourlies)
			I=hourly
		;;
		d|D|day|dailies)
			I=daily
		;;
		w|W|week|weeklies)
			I=weekly
		;;
		m|M|month|monthlies)
			I=monthly
		;;
	esac
	echo ${CONFIG[SNAP_${I}_DIR]}
}


# read in the config file
_ssched_read_config()
{
	if [ ! -s $CFGFILE ] ; then
		serr "Config file '$CFGFILE' is empty or non-existent."
		return 1
	fi
	if [ -r $CFGFILE ] ; then
		. $CFGFILE
	else
		serr "Config file '$CFGFILE' is not readable by you. (EPERM)"
		return 1
	fi
}

_ssched_output_config()
{

	for X in "${!CONFIG[@]}" ; do
		echo "CONFIG[$X]=\"${CONFIG[$X]}\""
	done
}

_ssched_write_config()
{

	# clear config file
	mv -f $CFGFILE ${CFGFILE}.bak 2>/dev/null

	_ssched_output_config > $CFGFILE
}

# give us a list of snapshot sources from the config
_ssched_list_srcs()
{
	echo ${!CONFIG[*]} | grep -o 'SSRC_[^ ]*' | grep -v \% | sed 's/^SSRC_//'

# alternate method.  which is better?
#	for I in "${!CONFIG[@]}" ; do
#		if [ "$I" = "${I#SSRC_}" ; then
#			continue
#		fi
#		if ! expr index "$I" '%' >/dev/null; then
#			SRCS_LIST+=" ${I#SSRC_}"
#		fi
#	done
#	echo $SRCS_LIST
}

# mount the btrfs subvolid=0 filesystem
_ssched_mount_rootvol()
{
	local BPATH="$1"

	UMNT=false

	if [ \( ! "$BPATH" \) -o \( ! -d "$BPATH" \) ] ; then
		return 1
	fi

	if ! grep -qw "$BPATH" /proc/mounts ; then
		mount "$BPATH" || return $?
		UMNT=true
	fi
}

# umount the btrfs subvolid=0 filesystem
_ssched_umount_rootvol()
{
	local BPATH="$1"

	if $UMNT ; then
		umount "$BPATH"
	fi
}


#command
ssched_list_sources()
{
	local SN SRCS

	_ssched_read_config

	SRCS=`_ssched_list_srcs`

	if [ "$1" = -v ] ; then
		echo -e "\t       Max\tMax\tMax\tMax\tHourly\tDaily\t\tWeekly\t  Monthly"
		echo -e "Fileset\t    hourlies dailies weeklies monthlies  TOD\tDAYS/TOD\tDAY/TOD   DOM/TOD            Databases"

		for S in $SRCS ; do
			if [ `expr length $S` -gt 12 ] ; then
				SN=`expr substr $S 1 12`
			else
				SN="$S"
			fi
			printf " %-14s%2d%9d%8d%8d\t%-8s%-16s%-10s%-18s %s\n" "$SN" ${CONFIG[SSRC_$S%H_MSC]} ${CONFIG[SSRC_$S%D_MSC]} ${CONFIG[SSRC_$S%W_MSC]} ${CONFIG[SSRC_$S%M_MSC]} "${CONFIG[SSRC_$S%H_TOD]-unset}" "${CONFIG[SSRC_$S%D_DAT]-n}/${CONFIG[SSRC_$S%D_TOD]-a}" "${CONFIG[SSRC_$S%W_DAT]-n}/${CONFIG[SSRC_$S%W_TOD]-a}" "${CONFIG[SSRC_$S%M_DAT]-n}/${CONFIG[SSRC_$S%M_TOD]-a}" `echo "${CONFIG[SSRC_$S%DBS]}" | sed 's/ /,/g'`
		done
	else
		echo $SRCS
	fi
}


# list snapsched snapshots for optional [source [interval[,interval...]]]
#command
ssched_lssnap()
{
	local NSRC
	local I S SRCS_LIST SDIR
	local -a INT_LIST
	local -u IUP

	if [ "$#" -ge 1 ] ; then
		NSRC="$1"
		_ssched_validate_nsrc NSRC "No source '$NSRC' found." || return 1
		SRCS_LIST="$NSRC"
		shift
	else
		_ssched_read_config
		SRCS_LIST="`_ssched_list_srcs`"
	fi

	if [ "$#" -ge 1 ] ; then
		INT_LIST=(${1//,/ })
		INT_LIST=${INT_LIST[*]/ies/y}
		for I in ${INT_LIST[*]} ; do
			case $I in
				hourly|daily|weekly|monthly)
					:
					;;
				*)
					serr "$0: invalid interval argument: '$I'"
					serr " interval argument is a [comma separated] list of one"
					serr " or more of {hourly, daily, weekly, montly}"
					return 1
					;;
			esac
		done
	else
		INT_LIST=(hourly daily weekly monthly)
	fi

	_ssched_mount_rootvol ${CONFIG[SNAP_MOUNT_DIR]} || return $?

	for S in $SRCS_LIST ; do
		echo "${S}:"
		SDIR="${CONFIG[SNAP_MOUNT_DIR]}/${CONFIG[SNAP_BASE_DIR]}/$S"
		for I in ${INT_LIST[*]} ; do
			# FIXME we need to extract things like the gen, ogen, otime
			# local ID GEN OGEN barf OD OT P
			# printf "%7s %7s %7s %10s %8s %s\n" ID GEN OGEN OD OT name
			# btrfs sub list -st ${CONFIG[SSRC_$S]} | while read ID GEN OGEN barf OD OT P ; do
			# if [ \( "$ID" = ID \) -o \( "$ID" = '--' \) ] ; then
			#	continue
			# fi
			# if ! echo $P | grep "${CONFIG[SNAP_BASE_DIR]}/$S/${CONFIG[SNAP_${IRVAL}_DIR]}" >/dev/null ; then
			#	continue
			# fi
			# printf "%7s %7s %7s %s %s %s\n" $ID $GEN $OGEN $OD $OT `basename $P`
			# done
			# another option is to use btrfs sub show, which lists snapshots
			# in their heirarchical order, which turns out to be cool
			# we could add a -h option to do that, and leave the interval
			# directory on the snapshot name so the user can see what type it is
			IUP=$I
			if [ -d $SDIR/${CONFIG[SNAP_${IUP}_DIR]} ] ; then
				echo "    ${I%y}ies:"
				ls $SDIR/${CONFIG[SNAP_${IUP}_DIR]} | sed 's/^/\t/'
			fi
		done
	done

	_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}
}



# delete specific cron entry in $ETC/cron.{hour,dai,week,month}ly/ directories
_ssched_remove_cron()
{
	local NSRC=$1
	local INT=$2
	local CRND=$ETC/cron.$INT/snapsched_`_ssched_nsrc2cronfile "$NSRC"`

	rm -f "$CRND"
}


#command -- to delete cron entries
ssched_delete_cronjobs()
{
	local NSRC=$1

	if [ -z "$NSRC" ] ; then
		NSRC='*'
	fi

	for I in hour dai week month ; do
		_ssched_remove_cron "$NSRC" ${I}ly
	done
}


#command -- to create cron entries
ssched_create_cronjobs()
{
	local NSRC=$1
	local -l NO_READ_CFG=${2:0:1}
	local JOB

	if ! _ssched_validate_nsrc NSRC "usage: create_cronjobs <source-name>" $NO_READ_CFG; then
		return 1
	fi

	for JOB in hour dai week month ; do

		JOB=${JOB}ly

		# if max snap count is 0, then snaps at that interval are disabled
		if [ ${CONFIG["SSRC_${NSRC}%`_ssched_int2l $JOB`_MSC"]} -eq 0 ] ; then
			continue
		fi

		_ssched_submit_cron $NSRC $JOB
	done
}


# initialize package crontab file in $ETC/cron.d
#    normally this should not be needed, as minimum $ETC/cron.d/snapsched
#    file should be included in package
_ssched_init_pkgcrontab()
{

	if [ ! -r $CRONTAB ] ; then
		cat <<-PKGCRONTABEND > $CRONTAB
			# snapsched package crontab
			# WARNING: this file is programmatically modified by the snapsched
			#     command without benefit of locking, so, if you hand edit, you
			#      might mess it up.  You have been warned sufficiently.
			SHELL=/bin/bash
			PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

		PKGCRONTABEND

	fi
}


# remove one line of package crontab file in $ETC/cron.d
# args: NSRC {hourly,daily,weekly,monthly}
_ssched_rm_pkgcrontab()
{
	local CFILE=$CRONTAB

	if [ ! -r $CFILE ] ; then
		return 1
	fi

	# entry may not exist
	sed -i "/^# $1 $2/,+1 d" $CFILE || true
}


# modify entry in package crontab file in $ETC/cron.d
# args: NSRC {hourly,daily,weekly,monthly} DARG CTIMES CPROG
_ssched_mod_pkgcrontab()
{
	local CFILE=$CRONTAB
	local NSRC="$1"

	if [ ! -r $CFILE ] ; then
		_ssched_init_pkgcrontab
	fi

	# previous entry may not exist
	_ssched_rm_pkgcrontab $NSRC $2 || true

	# FIXME should use the sed 'c' command
	echo "# $NSRC $2 DARG:'$3'" >> $CFILE
	echo -e "$4\troot\t$5 $PRE/lib/snapsched/scheduled $NSRC $2" >> $CFILE
}


#command -- to initialize the config file
ssched_init_config()
{

	if [ ! -d $ETCDIR ] ; then
		mkdir -p $ETCDIR
	fi

	# will overwrite anything existing

	CONFIG["SNAP_MOUNT_DIR"]=/media/btrfs
	CONFIG["SNAP_BASE_DIR"]=.ssched
	CONFIG["SNAP_HOURLY_DIR"]=hourly
	CONFIG["SNAP_DAILY_DIR"]=daily
	CONFIG["SNAP_WEEKLY_DIR"]=weekly
	CONFIG["SNAP_MONTHLY_DIR"]=monthly

	_ssched_write_config
	ssched_delete_cronjobs
	_ssched_init_pkgcrontab
}

#command
ssched_print_config()
{
	_ssched_read_config && _ssched_output_config || {
		echo "Error reading config file.   Perhaps it doesn't exist."
	}
}

_ssched_mysql_pause()
{
	local VNAME RESTO LCNT=0

	mysqladmin --defaults-extra-file=/etc/mysql/debian.cnf ping >/dev/null 2>&1
	if [ "$?" -ne 0 ] ; then
		echo "mysqld is not alive, cannot quiesce database!"
		return 1
	fi

	# -n means flush the buffer after each query
	coproc mysql --defaults-extra-file=/etc/mysql/debian.cnf -s -n

	if [ "$?" -ne 0 ] ; then
		echo "Failed to start coprocess: $0"
		return 1
	fi

	# save the value for innodb_max_dirty_pages_pct
	echo "show global variables;" > /dev/fd/${COPROC[1]}
	export MDPP=74
	while read -t 1 < /dev/fd/${COPROC[0]} VNAME MDPP ; do
		if [ "$VNAME" = innodb_max_dirty_pages_pct ] ; then
			break
		fi
	done
	while read -t 1 < /dev/fd/${COPROC[0]} RESTO ; do : ; done
	# echo "Saving innodb_max_dirty_pages_pct variable value $MDPP"

	# set it to zero
	echo "set global innodb_max_dirty_pages_pct=0;" > /dev/fd/${COPROC[1]}

	# flush and lock the tables
	echo "flush tables with read lock;" > /dev/fd/${COPROC[1]}

	# clear out the buffer
	while read -t 1 < /dev/fd/${COPROC[0]} RESTO ; do : ; done

	# wait for quiescence of innodb engine
	echo "show engine innodb status\G" > /dev/fd/${COPROC[1]}
	sleep 0.25
#echo "in thread wait loop"
	while read -t 1 < /dev/fd/${COPROC[0]} RESTO ; do
#echo "RESTO='$RESTO'"
		echo "$RESTO" | grep -q "^Main thread" || continue
		echo "$RESTO" |	grep -q "state: waiting for server activity" && break
#echo "non-matching RESTO: '$RESTO'"
# echo "$RESTO" |	grep -q "state: sleeping" && break

		# check to see if we need to bail 'cuz ain't hapnin
		LCNT=$(($LCNT + 1))
		if [ "$LCNT" -gt 30 ] ; then
			echo "Waiting for mysql innodb engine to quiesce timed out."
			echo "Cannot quiesce mysql database."
			echo "set global innodb_max_dirty_pages_pct=$MDPP;" > /dev/fd/${COPROC[1]}
			echo "unlock tables;" > /dev/fd/${COPROC[1]}
			echo -E "\q"  > /dev/fd/${COPROC[1]}
#echo "out thread wait loop"
			return 1
		fi

		while read -t 1 < /dev/fd/${COPROC[0]} TESTO ; do
			[ -z "$TESTO" ] && break
			TESTO=""
		done
		RESTO=
		# oh yeah, just spin for freakin ever
		echo "show engine innodb status\G" > /dev/fd/${COPROC[1]}
		sleep 0.25
#echo "LOOPING ==============================================================="
	done
#echo "out thread wait loop"
	while read -t 1 < /dev/fd/${COPROC[0]} RESTO ; do : ; done
#echo "mysql DB is paused"
	return 0
}

_ssched_mysql_unpause()
{

#echo "COPROC_ = '$COPROC'"
#echo "COPROC = '${COPROC[*]}'"

	if [ "${COPROC[1]}" ] ; then
		# restore innodb_max_dirty_pages_pct setting
		#echo "Restoring innodb_max_dirty_pages_pct variable value to $MDPP"
		echo "set global innodb_max_dirty_pages_pct=$MDPP;" > /dev/fd/${COPROC[1]}

		# unlock the tables
		echo "unlock tables;" > /dev/fd/${COPROC[1]}
		#echo "mysql DB is unpaused"

		# quit out of mysql client coprocess
		echo -E "\q"  > /dev/fd/${COPROC[1]}
	fi

	# might be some noise here
}

_ssched_pause_dbs()
{
	local CFGDBS="SSRC_${1}%DBS"
	local PES

	if [ -z "$1" ] ; then
		# nothing to do here
		return 0
	fi

	for DBP in ${CONFIG["$CFGDBS"]} ; do
		case $DBP in
			mysql)
				_ssched_mysql_pause
				PES=$?
				;;
			postgres*)
				#echo magic postgres incant to pause $DBP dbs
				PES=$?
				;;
			*)
				# FIXME nothing to see here
				;;
		esac
	done

	return $PES
}


_ssched_unpause_dbs()
{
	local CFGDBS="SSRC_${1}%DBS"

	if [ -z "$1" ] ; then
		# nothing to do here
		return 0
	fi

	for DBP in ${CONFIG["$CFGDBS"]} ; do
		case $DBP in
			mysql)
				_ssched_mysql_unpause
				;;
			postgres*)
				#echo magic postgres incant to unpause $DBP
				;;
			*)
				# FIXME nothing to see here
				;;
		esac
	done
}


# convert the NSRC source name to a file name acceptable by the cron idiots
_ssched_nsrc2cronfile()
{
	local SED_P1="s/@/at/g"
	local SED_P2="s/\./-/g"
	echo "$NSRC" | sed -e "$SED_P1" -e "$SED_P2"
}


# submit cron jobs for scheduled filesystem snapshots
_ssched_submit_cron()
{
	# args: interval {hourly, daily, weekly, monthly}, NSCR

	local NSRC=$1
	local INT=$2
	local CRND=$ETC/cron.$INT/snapsched_`_ssched_nsrc2cronfile "$NSRC"`

	# work around for stupid cron restriction on file names. of all the stupid.

	# this will overwrite existing, on purpose
	>$CRND
	cat >>$CRND <<THERE
#!/bin/sh
MAILTO=root

$PRE/lib/snapsched/scheduled $NSRC $INT
THERE
	chmod 755 $CRND
}


# change base path for btrfs filesystem
#command
ssched_set_btrfspath()
{
	_ssched_read_config

	_ssched_mount_rootvol "$1" || return $?

	_ssched_umount_rootvol "$1"

	CONFIG[SNAP_MOUNT_DIR]="$1"

	_ssched_write_config
}

# check the NSRC argument for validity
#    args: <nameref of nsrc variable> "usage message" [no-read-config]
#    side effect: normalized nsrc value
#
#    uses indirect variable method of passing nsrc so that the normalized
#    value can be passed back without having to use stdout.  using stdout
#    basically requires that the function be run in a sub-process, which
#    means that the reading of the config file doesn't load the CONFIG
#    array for the rest of the program.
_ssched_validate_nsrc()
{
	local UMSG
	local -l NO_READ_CFG # convert to lowercase on assignment

	if $OLDBASH ; then
		local LSRC
		eval LSRC=\${$1} # poor man's nameref functionality.  very poor man.
	else
		local -n LSRC=$1
	fi
	UMSG="$2"
	NO_READ_CFG="$3"

	if [ -z "$LSRC" ] ; then
		serr "$UMSG"
		return 1
	fi
	if expr index "$LSRC" / >/dev/null ; then
		LSRC=`basename $LSRC`
		# strips off trailing slashes too
	fi
	if expr index "$LSRC" '%' >/dev/null ; then
		serr "Cannot use '%' character in source name"
		return 1
	fi

	if [ "${#NO_READ_CFG}" -gt 1 ] ; then
		NO_READ_CFG="${NO_READ_CFG:0:1}"
	fi

	if [ "$NO_READ_CFG" != y ] ; then
		_ssched_read_config ||
			return 1
	fi

	# check to see if we have this in our config

	if [ -z "${CONFIG[SSRC_$LSRC]}" ] ; then
		serr "Fail: cannot locate source filesystem '$LSRC' in config file"
		return 1
	fi
	if $OLDBASH ; then
		eval $1="`basename ${CONFIG[SSRC_$LSRC]}`"
	else
		LSRC="`basename ${CONFIG[SSRC_$LSRC]}`"
	fi
}


# validate against max snap count
# args: nsrc msc intervals
_ssched_valid_min_msc()
{
	if [ "$2" -lt 1 ] ; then
		echo "Max snap count for '$1' $3 is set too low: $2"
		echo "No changes made.  Use mod_maxsnapcount to change."
		return 1
	fi
}


# change the max snap count for a particular source and interval
#command
ssched_mod_maxsnapcount()
{
	local NSRC
	local INT INTRVAL
	local NMAX
	local USTR MSG PLURAL

	USTR='usage: mod_maxsnapcount <file-system> <interval> <new max>\ninterval: one of hourly, daily, weekly, monthly\nnew-max: the new max snapcount'

	if [ "$#" -lt 3 ] ; then
		echo -e "$USTR"
		return 1
	fi

	NSRC="$1"

	_ssched_validate_nsrc NSRC "$USTR" ||
		return 1

	INT="$2"
	NMAX="$3"

	case "$INT" in
		hourly)
			if [ "$NMAX" -eq 0 ] ; then
				:
			elif [ \( "$NMAX" -lt 2 \) -o \( "$NMAX" -gt 36 \) ] ; then
				echo "Ill advised or illegal $INT max snapcount value of '$NMAX'"
				echo "Disregarding.  Pick another value, or use dailies to suppliment."
				return 1
			fi
			;;
		daily)
			if [ "$NMAX" -eq 0 ] ; then
				:
			elif [ \( "$NMAX" -lt 2 \) -o \( "$NMAX" -gt 14 \) ] ; then
				echo "Ill advised or illegal $INT max snapcount value of '$NMAX'"
				echo "Disregarding.  Pick another value, or use weeklies to suppliment."
				return 1
			fi
			;;
		weekly)
			if [ "$NMAX" -eq 0 ] ; then
				:
			elif [ \( "$NMAX" -lt 2 \) -o \( "$NMAX" -gt 10 \) ] ; then
				echo "Ill advised or illegal $INT max snapcount value of '$NMAX'"
				echo "Disregarding.  Pick another value, or use monthlies to suppliment."
				return 1
			fi
			;;
		monthly)
			if [ "$NMAX" -eq 0 ] ; then
				:
			elif [ \( "$NMAX" -lt 2 \) -o \( "$NMAX" -gt 24 \) ] ; then
				echo "Ill advised or illegal $INT max snapcount value of '$NMAX'"
				echo "Disregarding.  Pick a value from 2-24."
				return 1
			fi
			;;
		*)
			echo -e "$USTR"
			echo "Bad interval value: '$INT'"
			return 1
			;;
	esac

	INTRVAL=`_ssched_int2l $INT`
	PLURAL=${INT%y}ies
	OMAX=${CONFIG[SSRC_${NSRC}%${INTRVAL}_MSC]}

	if [ $NMAX = $OMAX ] ; then
		echo "No change for '$NSRC' $PLURAL"
		return 0
	fi
	if [ "$NMAX" -eq 0 ] ; then
		MSG="Turning $PLURAL OFF for source '$NSRC'"
	else
		MSG="Changing $INT max snapcount for '$NSRC' from '$OMAX' to '$NMAX'"
	fi

	echo "$MSG"

	CONFIG["SSRC_${NSRC}%${INTRVAL}_MSC"]=$NMAX

	if [ "$NMAX" -eq 0 ] ; then
		_ssched_rm_pkgcrontab $NSRC $INT
		_ssched_remove_cron $NSRC $INT
	else
		# if creating a new scheduled snapshot, make sure it's crons
		# are intact/created
		if [ "$OMAX" -eq 0 ] ; then
			if [ "${CONFIG[SSRC_$NSRC%${INTRVAL}_DAT]}" ] ; then
				# if it has special times/ set, then add
				# back the entry in the package crontab
				ssched_set_$PLURAL $NSRC \
					"${CONFIG[SSRC_$NSRC%${INTRVAL}_DAT]}" \
					"${CONFIG[SSRC_$NSRC%${INTRVAL}_TOD]}" \
					yes
				# no need to write the config file twice
				return
			else
				_ssched_submit_cron $NSRC $INT
			fi
		fi
	fi

	_ssched_write_config
}

####
# set_{hour,dai,week,month}lies commands
#
# These commands set specific times for the various scheduled snapshots
# to take place.  They can be combined with the MAX snapcount setting for
# their interval (hourly, daily, weekly, monthly) to fine tune a particular
# interval's scheduled snapping behavior.
# 
# Example: to set up daily snapshots of a filesystem named 'work' that
# most suits your work habits, or those who's data is on the filesystem,
# you decide you want the daily snapshots to fire at 11:00PM after most
# everyone has finished working for the day.  People rarely work on
# weekends, so you don't need to do daily snapshots on those days.  So,
# set max_snapcount (via the add_source command or the not-developed-yet
# mod_max command) to 6, to keep one extra just in case, and set the dailes
# to mon-fri 23:00.  You could also set the weeklies to complement this,
# say to fire on Sunday, which in a way would give you an extra snapshot
# to cover any work that happened on the weekend.


# set the daily snapshot fire time/day in the crontab file.
#
# default daily snapshot time is 12:00am (midnight) when set with this.
# when not set with this, it defaults to time of cron.daily job.  that
# might change one day.
#
# args: <file-system-name> <days> [<time-of-day>] [no-read-config]
# the no-read-config is for use of this function by other internal functions
#
#command
ssched_set_dailies()
{
	local NSRC DAYS TOD CTIMES
	local -l NO_READ_CFG # converts to lowercase on assignment
	local UMSG="usage: set_dailies <source-name> <days> [<tod>]"
	local THOUR=0 TMIN=1

	if [ "$#" -lt 2 ] ; then
		echo "$UMSG"
		return 1
	fi

	NSRC="$1"
	DAYS="$2"
	shift;shift
	if [ "$#" -eq 2 ] ; then
		TOD="$1"
		NO_READ_CFG="$2"
	elif [ "$#" -eq 1 ] ; then
		if [ "$1" = YES ] ; then
			NO_READ_CFG="$1"
		else
			TOD="$1"
		fi
	fi
	# shorten variable to one char
	if [ "${#NO_READ_CFG}" -gt 1 ] ; then
		NO_READ_CFG="${NO_READ_CFG:0:1}"
	fi

	# validate NSRC, and read config file if necessary
	_ssched_validate_nsrc NSRC "$UMSG" "$NO_READ_CFG" ||
		return 1

	# validate against max snap count
	_ssched_valid_min_msc $NSRC ${CONFIG["SSRC_$NSRC%D_MSC"]} dailies ||
		return 1


	if [ "$TOD" ] ; then
		case "$TOD" in
			[0-9][0-9]:[0-9][0-9])
				set -- ${TOD/:/ }
				# get rid of the leading zeroes
				THOUR=`printf "%d" "$1"`
				TMIN=`printf "%d" "$2"`
			   ;;
			*)
				echo "$UMSG"
				return 1
				;;
		esac
	fi

	# these should also be validated against max snap count
	case "$DAYS" in
		weekdays)
			CTIMES="$TMIN $THOUR * * mon-fri"
			;;
		weekend)
			# strange, but hey
			CTIMES="$TMIN $THOUR * * sat,sun"
			;;
		*)
			# FIXME validate things like mon-thu or 1-5 or 1,3,5,7
			CTIMES="$TMIN $THOUR * * $DAYS"
			;;
	esac

	CONFIG[SSRC_$NSRC%D_DAT]="$DAYS"
	CONFIG[SSRC_$NSRC%D_TOD]="$TOD"
	_ssched_write_config

	_ssched_mod_pkgcrontab "$NSRC" daily "$DAYS" "$CTIMES"

	# make sure the old $ETC/cron.daily is history
	_ssched_remove_cron $NSRC daily
}


# set the weekly snapshot fire time/day in the crontab file.  may place
#   a bit 'o code into the crontab file
#
# default weekly snapshot time is sat 12:00am (midnight) when set with this.
# when not set with this, it defaults to time of cron.weekly job.  that
# might change one day.
#
# args: <file-system-name> <day> [<time-of-day>] [no-read-config]
# the no-read-config is for use of this function by other internal functions
#
#command
ssched_set_weeklies()
{
	local NSRC TOD CTIMES
	local -l DAY NO_READ_CFG # converts to lowercase on assignment
	local THOUR=0 TMIN=1
	local UMSG="usage: set_weeklies <source-name> <day> [<tod>]"

	if [ "$#" -lt 2 ] ; then
		echo "$UMSG"
		return 1
	fi

	NSRC="$1"
	DAY="$2"
	shift;shift
	if [ "$#" -eq 2 ] ; then
		TOD="$1"
		NO_READ_CFG="$2"
	elif [ "$#" -eq 1 ] ; then
		if [ "$1" = YES ] ; then
			NO_READ_CFG="$1"
		else
			TOD="$1"
		fi
	fi
	# shorten variable to one char
	if [ "${#NO_READ_CFG}" -gt 1 ] ; then
		NO_READ_CFG="${NO_READ_CFG:0:1}"
	fi

	# validate NSRC, and read config file if necessary
	_ssched_validate_nsrc NSRC "$UMSG" "$NO_READ_CFG" ||
		return 1

	# validate against max snap count
	_ssched_valid_min_msc $NSRC ${CONFIG["SSRC_$NSRC%W_MSC"]} weeklies ||
		return 1


	if [ "$TOD" ] ; then
		case "$TOD" in
			[0-9][0-9]:[0-9][0-9])
				set -- ${TOD/:/ }
				# get rid of the leading zeroes
				THOUR=`printf "%d" "$1"`
				TMIN=`printf "%d" "$2"`
			   ;;
			*)
				echo "$UMSG"
				return 1
				;;
		esac
	fi

	# these should also be validated against max snap count
	case "$DAY" in
		mon|tue|wed|thu|fri|sat|sun)
			CTIMES="$TMIN $THOUR * * $DAY"
			;;
		[1-7])
			# numerical day specifier
			CTIMES="$TMIN $THOUR * * $DAY"
			;;
		*)
			echo "$UMSG"
			return 1
			;;
	esac

	CONFIG[SSRC_$NSRC%W_DAT]="$DAY"
	CONFIG[SSRC_$NSRC%W_TOD]="$TOD"
	_ssched_write_config

	_ssched_mod_pkgcrontab "$NSRC" weekly "$DAY" "$CTIMES" ""

	# make sure the old $ETC/cron.weekly is history
	_ssched_remove_cron $NSRC weekly
}


# set the montly snapshot fire time/day in the crontab file.  may place
#   a bit 'o code into the crontab file
#
# args: <file-system-name> <day-of-month> [<time-of-day>] [no-read-config]
# the no-read-config is for use of this function by other internal functions
#
#command
ssched_set_monthlies()
{
	local NSRC DOM TOD
	local -l NO_READ_CFG # converts to lowercase on assignment
	local THOUR=22 TMIN=5
	local CPROG CTIMES
	local UMSG="usage: set_monthlies <source-name> <dom> [<tod>]"

	if [ "$#" -lt 2 ] ; then
		echo "$UMSG"
		return 1
	fi

	NSRC="$1"
	DOM="$2"
	shift;shift
	if [ "$#" -eq 2 ] ; then
		TOD="$1"
		NO_READ_CFG="$2"
	elif [ "$#" -eq 1 ] ; then
		if [ "$1" = YES ] ; then
			NO_READ_CFG="$1"
		else
			TOD="$1"
		fi
	fi
	if [ "$NO_READ_CFG" ] ; then
		NO_READ_CFG="${NO_READ_CFG:0:1}"
	fi

	# validate NSRC, and read config file if necessary
	_ssched_validate_nsrc NSRC "$UMSG" "$NO_READ_CFG" ||
		return 1

	# validate against max snap count
	_ssched_valid_min_msc $NSRC ${CONFIG["SSRC_$NSRC%M_MSC"]} monthlies ||
		return 1

	if [ "$TOD" ] ; then
		case "$TOD" in
			[0-9][0-9]:[0-9][0-9])
				set -- ${TOD/:/ }
				# get rid of the leading zeroes
				THOUR=`printf "%d" "$1"`
				TMIN=`printf "%d" "$2"`
			   ;;
			*)
				echo "$UMSG"
				return 1
				;;
		esac
	fi

	case "$DOM" in
		last-weekday)
			CPROG='[ "`date +\%e`" = $(ncal -h | egrep '\''Mo|Tu|We|Th|Fr'\'' | sed '\''s/^.* \([0-9]\+\) *$/\1/'\'' | sort | tail -1) ] && '
			CTIMES="$TMIN $THOUR 26-31 * mon-fri"
			;;
		last-weekend)
			CPROG='[ "`date +\%e`" = $(ncal -h | egrep '\''Su|Sa'\'' | sed '\''s/^.* \([0-9]\+\) *$/\1/'\'' | sort | tail -1) ] && '
			CTIMES="$TMIN $THOUR 23-31 * sat,sun"
			;;
		last-*)
			local -l LDAY
			local SDAY
			LDAY=`echo $DOM | sed 's/^last-//'`
			echo $LDAY | egrep -q 'sat|sun|mon|tue|wed|thu|fri' || {
				echo "I don't understand that one: '$DOM'"
				echo "Check out the help message for acceptable 'last' values"
				return 1
			}
			SDAY=`echo $LDAY | sed 's/.$//'`
			CPROG='[ "`date +\%e`" = $(ncal -h | grep -i '$SDAY' | sed '\''s/^.* \([0-9]\+\) *$/\1/'\'') ] && '
			CTIMES="$TMIN $THOUR 22-31 * $LDAY"
			;;
		last)
			CPROG='[ "`date +\%e`" = $(cal -h | sed '\''/^ *$/d'\'' | tail -1 | sed '\''s/^.* \([23][018]\) *$/\1/'\'') ] && '
			CTIMES="$TMIN $THOUR 28-31 * *"
			;;
		[1-9]|1[0-9]|2[0-9]|3[01])
			CPROG=
			CTIMES="$TMIN $THOUR $DOM * *"
			;;
		*)
			echo "I don't understand that one: '$DOM'"
			echo "Check out the help message for acceptable numerical values"
			return 1
			;;
	esac

	CONFIG[SSRC_$NSRC%M_DAT]="$DOM"
	CONFIG[SSRC_$NSRC%M_TOD]="$TOD"
	_ssched_write_config

	_ssched_mod_pkgcrontab "$NSRC" monthly "$DOM" "$CTIMES" "$CPROG"

	# make sure the old $ETC/cron.monthly is history
	_ssched_remove_cron $NSRC monthly
}


# add a subvolume to the config for scheduled snapshots
#command
ssched_add_source()
{
	local SRCDIR NSRC H D W M
	local -l ANS

	# arguments:

	# name   h d w m [db1 ...dbn]
	# examples:
	#   ssched_add_source r00t 25 6 5 13 mysql postgresql-9.1
	#   ssched_add_source h0me 24 8 0 12

	# check caller
	if [ "$SSCHED_UBER" != y ] ; then
		return 1
	fi

	if [ "$#" -lt 5 ] ; then
		echo "usage: add_source name   h d w m [db1 ...dbn]"
		return 1
	fi

	NSRC=$1
	shift

	if _ssched_validate_nsrc NSRC 2>/dev/null ; then
		echo "Source '$NSRC' already exists in config file."
		read -p "Are you sure you want to overwrite it? [Ny] " ANS
		if [ -z "$ANS" ] ; then
			return 0
		fi
		ANS=${ANS:0:1}
		if [ "$ANS" -ne y ] ; then
			return 0
		fi
	fi

	_ssched_mount_rootvol ${CONFIG[SNAP_MOUNT_DIR]} || return $?

	SRCDIR=${CONFIG[SNAP_MOUNT_DIR]}/$NSRC

	if [ ! -d $SRCDIR ] ; then
		echo "Couldn't find $SRCDIR.  You have to have a volume or snapshot to make snapshots of, asshole."
		_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}
		return 1
	fi

	_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}

	# this will overwrite any previous config for this source
	CONFIG["SSRC_$NSRC"]=$SRCDIR

	local ILEN=`expr length SSRC_${NSRC}%`
	for H in "${!CONFIG[@]}" ; do
		if [ `expr match SSRC_$NSRC% $H` -gt "$ILEN" ] ; then
			unset CONFIG[$H]
		fi
	done


	# process the max snap count for hourlies
	if [ "$1" -lt 0 ] ; then
		echo "Overriding max snap count for hourlies to 0 (disabled)"
		H=0
	elif [ "$1" -gt 36 ] ; then
		echo "Overriding max snap count for hourlies to 36"
		H=36
	else
		H=$1
	fi
	CONFIG["SSRC_${NSRC}%H_MSC"]=$H
	shift

	# process the max snap count for dailies
	if [ "$1" -lt 0 ] ; then
		echo "Overriding max snap count for dailies to 0 (disabled)"
		D=0
	elif [ "$1" -gt 14 ] ; then
		echo "Overriding max snap count for dailies to 14"
		D=14
	else
		D=$1
	fi
	CONFIG["SSRC_${NSRC}%D_MSC"]=$D
	shift

	# process the max snap count for weeklies
	if [ "$1" -lt 0 ] ; then
		echo "Overriding max snap count for weeklies to 0 (disabled)"
		W=0
	elif [ "$1" -gt 10 ] ; then
		echo "Overriding max snap count for weeklies to 10"
		W=10
	else
		W=$1
	fi
	CONFIG["SSRC_${NSRC}%W_MSC"]=$W
	shift

	# process the max snap count for monthlies
	if [ "$1" -lt 0 ] ; then
		echo "Overriding max snap count for monthlies to 0 (disabled)"
		M=0
	elif [ "$1" -gt 24 ] ; then
		echo "Overriding max snap count for monthlies to 24"
		M=24
	else
		M=$1
	fi
	CONFIG["SSRC_${NSRC}%M_MSC"]=$M
	shift

	# process the DBs argument
	CONFIG["SSRC_${NSRC}%DBS"]="$*"

	_ssched_write_config

	ssched_create_cronjobs $NSRC yes
}


# remove a subvolume to the config for scheduled snapshots
#command
ssched_remove_source()
{
	local SRCDIR NSRC SSNAPS_BDIR CHILD_SNAPS ES
	local -l ANS
	local I R

	# arguments: filesystem name

	# check caller
	if [ "$SSCHED_UBER" != y ] ; then
		return 1
	fi

	NSRC=$1

	_ssched_validate_nsrc NSRC "$0: <filesystem-source>" ||
		return 1

	_ssched_mount_rootvol ${CONFIG[SNAP_MOUNT_DIR]} || return $?

	SRCDIR=${CONFIG[SNAP_MOUNT_DIR]}/$NSRC

	if [ ! -d $SRCDIR ] ; then
		echo "Couldn't find $SRCDIR.  Fail.  Bye."
		_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}
		exit 1
	fi

	# FIXME what about deleting the scheduled snapshots?!?
	# use btrfs show command to list snapshots OR
	# use btrfs list -u [idiotic output] | grep "path $SRCDIR"
	# then use btrfs sub del -c `btrfs list -q | grep "parent_uuid $UUID"`
	# not really, but i get the idea
	# MUST BE VERY CAREFUL, because a child snapshot might be a newly added
	# source or other important snapshot.  so look only for
	# snapshots under .ssched/$NSRC/
	ANS=
	SSNAPS_BDIR="${CONFIG[SNAP_MOUNT_DIR]}/${CONFIG[SNAP_BASE_DIR]}/$NSRC"
	CHILD_SNAPS=$SSNAPS_BDIR/*/*
	if [ "$CHILD_SNAPS" != "$SSNAPS_BDIR/*/*" ] ; then
		echo "Delete all the scheduled snapshot of this former source?"
		echo $CHILD_SNAPS |
			sed "s|^$SSNAPS_BDIR/||" | sed "s|$SSNAPS_BDIR/|\n|g"
		read -p "Answer must be 'yes' to delete.  Really delete all? " ANS
		if [ "$ANS" = yes ] ; then
			btrfs sub del -c $CHILD_SNAPS
		else
			ANS=
			echo "As you wish.  The source '$NSRC' will be removed from the config file"
		fi
	fi

	ES=0
	echo "Do you wish to delete the source subvolume itself?"
	echo "This has no effect on scheduled snapshots of the subvolume, which"
	echo "you have${ANS:= not} already deleted."
	ANS=
	read -p "[no]/yes ? " ANS
	if [ "$ANS" = yes ] ; then
		echo "Are you super-sure?  This is very dangerous, and you MUST"
		echo "know exactly what you are doing!"
		read -p "Are you double-sure you want to delete subvolume '$NSRC' No/yes ? " ANS
		if [ "$ANS" = yes ] ; then
			btrfs sub del -c "$SRCDIR"
			ES=$?
		fi
	fi

	_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}

	if [ "$ES" -ne 0 ] ; then
		serr "Error deleting snapshot dir '$SRCDIR': $ES"
	fi

	# delete them
	unset CONFIG["SSRC_$NSRC"]
	unset CONFIG["SSRC_${NSRC}%H_MSC"]
	unset CONFIG["SSRC_${NSRC}%D_MSC"]
	unset CONFIG["SSRC_${NSRC}%W_MSC"]
	unset CONFIG["SSRC_${NSRC}%M_MSC"]
	unset CONFIG["SSRC_${NSRC}%DBS"]
	for I in hour dai week month ; do
		I=${I}ly
		R=`_ssched_int2l $I`
		if [ "${CONFIG[SSRC_$NSRC%${R}_DAT]}" ] ; then
			unset CONFIG[SSRC_$NSRC%${R}_DAT]
			unset CONFIG[SSRC_$NSRC%${R}_TOD]
			# if the MSC was zero for this interval, then there won't
			# be an entry to delete, but whatever
			_ssched_rm_pkgcrontab $NSRC $I
		fi
	done

	_ssched_write_config

	ssched_delete_cronjobs $NSRC

	echo "Scheduled snapshot source '$NSRC' removed from config file and"
	echo "cron jobs."
}


#command
ssched_diff()
{
	local NSRC FNAM ES BN=1
	local -l INTTYPE
	local USTR="usage: diff <source-name> <int-type> <file-name> [<back-num>]"

	if [ "$#" -lt 3 ] ; then
		serr "wrong number of arguments: $#"
		echo "$USTR"
		return 1
	fi

	NSRC="$1"
	INTTYPE="$2"
	FNAM="$3"
	shift;shift;shift
	if [ "$#" -eq 1 ] ; then
		BN="$1"
		if [ "$BN" -lt 1 ] ; then
			serr "$USTR"
			serr "Back-num invalid value '$BN'"
			return 1
		fi
	fi

	if [ -d "$FNAM" ] ; then
		serr "$USTR"
		serr "Can't diff directories (yet). '$FNAM'"
		return 1
	elif [ -e "$FNAM" -a ! -r "$FNAM" ] ; then
		serr "$USTR"
		serr "Can't open file for reading: '$FNAM'"
		return 1
	fi

	# validate NSRC, and read config file if necessary
	_ssched_validate_nsrc NSRC "$USTR" ||
		return 1

	# validate int type
	case "$INTTYPE" in
		h|hour*)
			INTR=hourly
			;;
		d|day*|daily|dailies)
			INTR=daily
			;;
		w|week*)
			INTR=weekly
			;;
		m|month*)
			INTR=monthly
			;;
		*)
			serr -e "$USTR"
			serr "Bad interval value: '$INTTYPE'"
			return 1
			;;
	esac

	_ssched_mount_rootvol ${CONFIG[SNAP_MOUNT_DIR]} || return $?

	SDIR="${CONFIG[SNAP_MOUNT_DIR]}/${CONFIG[SNAP_BASE_DIR]}/$NSRC/`_ssched_int2dir $INTR`"
	if [ "$BN" -gt "`\ls $SDIR | wc -l`" ] ; then
		serr "Specified back-num '$BN' is greater than available '`\ls $SDIR | wc -l`'"
		_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}
		return 1
	fi
	SDIR="$SDIR/`\ls $SDIR | tail -$BN | head -1`"

	if expr match "$FNAM" / >/dev/null ; then
		FPATH="$FNAM"
	else
		FPATH="`pwd`/$FNAM"
	fi
	FPATH=${FPATH#/}

	# whatever errors diff gets about no files, etc,
	#  just poop 'em on to the user
	${SSCHED_DIFF:-diff} --new-file "$SDIR/$FPATH" "$FNAM"
	ES=$?

	_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}

	return $ES
}


# copy a file out of a snapshot.  code could conceivably be combined with
# the diff command at some point.  also, could add support for things
# like rsync and the like.  use your own copy command in SSCHED_GET if you dare
#command
ssched_get()
{
	local NSRC FNAM ES BN=1
	local -l INTTYPE
	local CP_CMD
	local USTR="usage: get <source-name> <int-type> <file-name> <out-file-name> [<back-num>]\noutput filename can be '-' for stdout"

	if [ "$#" -lt 3 ] ; then
		serr "wrong number of arguments: $#"
		echo "$USTR"
		return 1
	fi

	NSRC="$1"
	INTTYPE="$2"
	FNAM="$3"
	ONAM="$4"
	shift;shift;shift;shift
	if [ "$#" -eq 1 ] ; then
		BN="$1"
		if [ "$BN" -lt 1 ] ; then
			serr "$USTR"
			serr "Back-num invalid value '$BN'"
			return 1
		fi
	fi

	if [ -e "$ONAM" -a ! -w "$ONAM" ] ; then
		serr "$USTR"
		serr "File exists, but you can't write to it: '$ONAM'"
		return 1
	fi

	# validate NSRC, and read config file if necessary
	_ssched_validate_nsrc NSRC "$USTR" ||
		return 1

	# validate int type
	case "$INTTYPE" in
		h|hour*)
			INTR=hourly
			;;
		d|day*|daily|dailies)
			INTR=daily
			;;
		w|week*)
			INTR=weekly
			;;
		m|month*)
			INTR=monthly
			;;
		*)
			serr -e "$USTR"
			serr "Bad interval value: '$INTTYPE'"
			return 1
			;;
	esac

	_ssched_mount_rootvol ${CONFIG[SNAP_MOUNT_DIR]} || return $?

	SDIR="${CONFIG[SNAP_MOUNT_DIR]}/${CONFIG[SNAP_BASE_DIR]}/$NSRC/`_ssched_int2dir $INTR`"
	if [ "$BN" -gt "`\ls $SDIR | wc -l`" ] ; then
		serr "Specified back-num '$BN' is greater than available '`\ls $SDIR | wc -l`'"
		_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}
		return 1
	fi
	SDIR="$SDIR/`\ls $SDIR | tail -$BN | head -1`"

	if expr match "$FNAM" / >/dev/null ; then
		FPATH="$FNAM"
	else
		FPATH="`pwd`/$FNAM"
	fi
	FPATH=${FPATH#/}

	if [ -d "$SDIR/$FPATH" ] ; then
		serr "$USTR"
		serr "Can't copy directories (yet). '${SDIR#${CONFIG[SNAP_MOUNT_DIR]}}/$FPATH'"
		_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}
		return 1
	fi

	CP_CMD=cp
	if [ \( ${#ONAM} = 1 \) -a \( "$ONAM" = "-" \) ] ; then
		ONAM=
		CP_CMD=cat
	fi

	# whatever errors cp gets about no files, etc,
	#  just poop 'em on to the user
	${SSCHED_GET:-$CP_CMD} "$SDIR/$FPATH" "$FNAM" $ONAM
	ES=$?

	_ssched_umount_rootvol ${CONFIG[SNAP_MOUNT_DIR]}

	return $ES
}
